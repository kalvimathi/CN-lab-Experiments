EX.NO. 10. SIMULATION OF ERROR CORRECTION CODE (CRC)

AIM:
To simulate the error correction code like CRC using java.
Cyclic redundancy check (CRC)
● Unlike checksum scheme, which is based on addition, CRC is based on binary
division.
● In CRC, a sequence of redundant bits, called cyclic redundancy check bits, are
appended to the end of data unit so that the resulting data unit becomes exactly
divisible by a second, predetermined binary number.
● At the destination, the incoming data unit is divided by the same number. If at this
step there is no remainder, the data unit is assumed to be correct and is therefore
accepted.
● A remainder indicates that the data unit has been damaged in transit and therefore
must be rejected.

EXAMPLE :

ALGORITHM:
Step 1: Open the editor and type the program for error detection
Step 2: Get the input in the form of bits.
Step 3: Append the redundancy bits.
Step 4: Divide the appended data using a divisor polynomial.
Step 5: The resulting data should be transmitted to the receiver.
Step 6: At the receiver the received data is entered.
Step 7: The same process is repeated at the receiver.
Step 8: If the remainder is zero there is no error otherwise there is some error in the received
bits
Step 9: Run the program.

Code:
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
int main() {
int i, j, k, count, err_pos = 0, flag = 0;
char dw[20], cw[20], data[20];
printf("Enter data as binary bit stream (7 bits):\n");
scanf("%s", data);
// Generating the codeword with parity bits
for (i = 1, j = 0, k = 0; i < 12; i++) {
if (i == (int)pow(2, j)) {
dw[i] = '?';
j++;
} else {
dw[i] = data[k];
k++;
}
}
// Calculating parity bits
for (i = 0; i < 4; i++) {
count = 0;
for (j = (int)pow(2, i); j < 12; j += (int)pow(2, i) * 2) {
for (k = 0; k < (int)pow(2, i) && j + k < 12; k++) {
if (dw[j + k] == '1') count++;
}
}
dw[(int)pow(2, i)] = (count % 2 == 0) ? '0' : '1';
}
// Printing the generated codeword
printf("Generated code word is:\n");
for (i = 1; i < 12; i++) {
printf("%c", dw[i]);
}
printf("\n\nEnter the received Hamming code:\n");
scanf("%s", cw);
// Adjusting the index for 1-based numbering
for (i = 12; i > 0; i--) {
cw[i] = cw[i - 1];
}
// Error detection
for (i = 0; i < 4; i++) {

count = 0;
for (j = (int)pow(2, i); j < 12; j += (int)pow(2, i) * 2) {
for (k = 0; k < (int)pow(2, i) && j + k < 12; k++) {
if (cw[j + k] == '1') count++;
}
}
if (count % 2 != 0) {
err_pos = err_pos + (int)pow(2, i);
}
}
// Error correction
if (err_pos == 0) {
printf("\n\nThere is no error in the received code word.\n");
} else {
if (cw[err_pos] == dw[err_pos]) {
printf("\n\nThere are 2 or more errors in the received code...\n");
printf("Sorry...! Hamming code cannot correct 2 or more errors.\n");
flag = 1;
} else {
printf("\n\nThere is an error in bit position %d of the received code word.\n", err_pos);
if (flag == 0) {
cw[err_pos] = (cw[err_pos] == '1') ? '0' : '1';
printf("\n\nCorrected code word is:\n");
for (i = 1; i < 12; i++) {
printf("%c", cw[i]);
}
}
}
}
printf("\n\n");
return 0;
}
OUTPUT:

RESULT:
Thus the simulation of error correction code (like CRC) has been executed
successfully and output got verified.
